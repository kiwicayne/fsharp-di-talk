We will introduce F#, see how F# doesn't require as much ceremony as C#.  How dependency injection can be done in F#, and why it isn't as much of an issue as it is in C#.

Start off porting Step 1 from C# to F#, then make the code more functional and finally look at DI.  

Compare the original C# Step 5 ninject solution to F# solution(s), which do you prefer?

Example
-------
Application to send messages to people, names loaded from a file.  Same application used in C# ninject talk.

1. Translate C# Step 1 directly into F# using OOP
  - F# allows full OOP with less ceremony!

2. Translate OO to a more Function style - encapsulation via module instead of class - Single Responsibility
  - pass filename into the function instead of a constructor
  - Split the function into reading names and sending messages as in step 2 of C# example

3. Move modules into different files.  Create ConsoleWriter and MessageSender.  Same as Step3 from C# example.

4. Introduce Rop - simple overview of how F# makes a DSL easy. This is an example of a functional "design pattern"

Review
------
type signitures instead of interfaces - large reduction in code

OOP is about encapsulating functionality and data together into a type.  

Functional still has encapsulation (modules/can have functions on a type) but generally keeps the types and functions that operate on those types seperate unless they are very tighly coupled and changing one always requires changing the other (e.g. toJson).

F# is a hybrid.  Very good at OOP or Functional.  Use the best of both worlds.